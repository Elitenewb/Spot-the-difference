<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Spot the Difference – Player</title>
  <style>
    :root{--bg:#0f1220;--panel:#171a2b;--ink:#e9ecf1;--muted:#a7b0c0;--accent:#7bd4ff;--frame:#2a2f4a;--good:#53d769;--bad:#ff5c5c}
    *{box-sizing:border-box}
    html,body{height:100%}
    body{margin:0;background:linear-gradient(180deg,#0f1220,#0b0e1a);color:var(--ink);font:14px/1.4 system-ui,Segoe UI,Roboto,Helvetica,Arial}
    header{padding:16px 20px;border-bottom:1px solid #23263d;display:flex;align-items:center;justify-content:space-between}
    h1{margin:0;font-size:18px}
    main{display:grid;grid-template-columns:320px 1fr;min-height:calc(100% - 58px)}
    body.playing main{grid-template-columns:1fr}
    aside{padding:16px;border-right:1px solid #23263d;background:var(--panel)}
    body.playing aside{display:none}
    .section{margin-bottom:16px}
    label{display:block;margin:8px 0 6px;color:var(--muted)}
    input[type="file"],button{width:100%;padding:10px;border:1px solid #2b3152;border-radius:10px;background:#0e1122;color:var(--ink)}
    button{cursor:pointer}
    button.primary{background:var(--accent);border-color:#66c9fb;color:#001019;font-weight:600}
    .row{display:flex;gap:10px}

    .card{background:var(--panel);border:1px solid #23263d;border-radius:14px;padding:12px}
    .game{display:grid;grid-template-columns:1fr 1fr;gap:18px;padding:18px}

    /* Frames match image aspect ratio at runtime */
    .frame{position:relative;border:3px solid var(--frame);border-radius:12px;overflow:hidden;background:#0a0d1b}

    /* Left (play) side: two stacked HTML <img> to avoid SVG/canvas color shifts */
    .stack{position:relative;width:100%;height:100%}
    .layer{position:absolute;inset:0;width:100%;height:100%;display:block;object-fit:fill;image-rendering:auto;filter:none;mix-blend-mode:normal;}
    /* mask applied to #modLeft only */

    /* Right (reference) */
    #origRight{width:100%;height:100%;object-fit:fill;display:block}

    .badge{position:absolute;top:8px;left:8px;background:#000c;color:#fff;padding:4px 8px;border-radius:999px;font-size:12px;border:1px solid #ffffff22}
    body.playing .badge{display:none}

    .bar{height:8px;background:#10142b;border:1px solid #2b3152;border-radius:999px;overflow:hidden}
    .fill{height:100%;background:linear-gradient(90deg,#66c9fb,#7bd4ff)}

    .stats{display:flex;gap:10px;flex-wrap:wrap}
    .chip{background:#0e1327;border:1px solid #2b3152;border-radius:999px;padding:6px 10px;color:var(--muted)}
    .gain{background:#0a1a0f;border-color:#1f6f3b;color:#c7f7d1}

    .hintPulse{position:absolute;border:2px solid #fff;border-radius:50%;opacity:0;pointer-events:none;z-index:5}

    .modal{position:fixed;inset:0;background:#0009;display:none;align-items:center;justify-content:center}
    .modal .inner{background:#0f142e;border:1px solid #2b3152;border-radius:16px;max-width:420px;width:92%;padding:20px}
    .modal h2{margin:0 0 12px}
    .modal .row{display:flex;justify-content:space-between;margin-top:10px}

    .hud{display:none;gap:12px;align-items:center;justify-content:center;padding:10px 18px;border-top:1px solid #23263d}
    body.playing .hud{display:flex}
    .hud .timer{font-variant-numeric:tabular-nums;background:#0e1327;border:1px solid #2b3152;border-radius:10px;padding:8px 12px;color:var(--muted)}

    .under-left{display:none;justify-content:center;padding:10px}
    body.playing .under-left{display:flex}
    .btn{padding:10px 14px;border-radius:10px;border:1px solid #2b3152;background:#0e1122;color:var(--ink);cursor:pointer}
  </style>
</head>
<body>
  <header>
    <h1>Spot the Difference</h1>
    <div class="stats">
      <div class="chip">Total: <span id="score">0</span></div>
      <div class="chip gain" id="lastGain" style="display:none">+0</div>
      <div class="chip">Time Bonus: <span id="bonus">1000</span></div>
      <div class="chip">Found: <span id="found">0</span>/<span id="need">10</span></div>
    </div>
  </header>
  <main>
    <aside>
      <div class="section">
        <label>Load Modified (left)</label>
        <input id="modFile" type="file" accept="image/*" />
        <label>Load Original (right)</label>
        <input id="origFile" type="file" accept="image/*" />
        <label>Load Config (JSON)</label>
        <input id="cfgFile" type="file" accept="application/json" />
      </div>
      <div class="section row">
        <button id="startBtn" class="primary">Start game</button>
        <button id="resetBtn">Reset game</button>
      </div>
      <div class="section">
        <div class="bar"><div id="bonusFill" class="fill" style="width:100%"></div></div>
        <div class="hint" style="color:var(--muted);margin-top:6px">Each find = <b>200</b> + current time bonus (1000→0 over 20s). Wrong click: <span style="color:var(--bad)">-25</span>.</div>
      </div>
    </aside>
    <div class="game">
      <div class="card">
        <div class="frame" id="leftFrame">
          <span class="badge">Modified (clickable)</span>
          <div class="stack" id="stack">
            <img id="origLeft" class="layer" alt="Original (below)" />
            <img id="modLeft" class="layer" alt="Modified (masked)" />
          </div>
        </div>
        <div class="under-left"><button id="hintBtnUnder" class="btn" type="button">Hint</button></div>
      </div>
      <div class="card">
        <div class="frame" id="rightFrame">
          <span class="badge">Original (reference)</span>
          <img id="origRight" alt="Original" />
        </div>
      </div>
    </div>
  </main>

  <div class="hud" id="hud"><div id="upTimer" class="timer">00:00</div></div>

  <div id="doneModal" class="modal">
    <div class="inner">
      <h2>Complete ✅</h2>
      <p>Total Time: <span id="sumTime">—</span></p>
      <p>Total Score: <span id="sumScore">—</span></p>
      <div class="row">
        <button id="closeModal" class="primary">Close</button>
        <button id="playAgain">Play again</button>
      </div>
    </div>
  </div>

  <script>
    // Elements
    const modFile = document.getElementById('modFile');
    const origFile = document.getElementById('origFile');
    const cfgFile = document.getElementById('cfgFile');
    const startBtn = document.getElementById('startBtn');
    const hintBtnUnder = document.getElementById('hintBtnUnder');
    const resetBtn = document.getElementById('resetBtn');

    const leftFrame = document.getElementById('leftFrame');
    const rightFrame = document.getElementById('rightFrame');
    const stack = document.getElementById('stack');
    const modLeft = document.getElementById('modLeft');
    const origLeft = document.getElementById('origLeft');
    const origRight = document.getElementById('origRight');

    const scoreEl = document.getElementById('score');
    const lastGainEl = document.getElementById('lastGain');
    const foundEl = document.getElementById('found');
    const needEl = document.getElementById('need');
    const bonusEl = document.getElementById('bonus');
    const bonusFill = document.getElementById('bonusFill');
    const upTimerEl = document.getElementById('upTimer');

    const doneModal = document.getElementById('doneModal');
    const closeModal = document.getElementById('closeModal');
    const playAgain = document.getElementById('playAgain');

    // State
    let modImg = new Image();
    let origImg = new Image();
    let cfg = null; // {radiusNorm, points[{xNorm,yNorm}], need, natural{w,h}}
    let found = new Set();
    let score = 0;

    let upStart = 0; // ms
    let upTimerId = null;

    let bonusStart = 0; // ms timestamp for current 20s window
    const BONUS_WINDOW = 20000; // 20s
    const BONUS_MAX = 1000;

    // Hint radius multiplier (bigger, per request)
    const HINT_FACTOR = 5;

    function imagesReady(){ return modImg.naturalWidth && origImg.naturalWidth; }

    // Hidden mask canvas: white = keep modified, black = reveal original
    const maskCanvas = document.createElement('canvas');
    const mctx = maskCanvas.getContext('2d');

    function setAspectToNatural(){
      const w = cfg?.natural?.w || modImg.naturalWidth;
      const h = cfg?.natural?.h || modImg.naturalHeight;
      if (w && h){
        leftFrame.style.aspectRatio = `${w} / ${h}`;
        rightFrame.style.aspectRatio = `${w} / ${h}`;
      }
    }

    function sizeMaskToDisplay(){
      const rect = modLeft.getBoundingClientRect();
      const bw = Math.max(1, Math.round(rect.width));
      const bh = Math.max(1, Math.round(rect.height));
      if (maskCanvas.width !== bw || maskCanvas.height !== bh){
        maskCanvas.width = bw; maskCanvas.height = bh;
      }
    }

    function radiusPx(){
      const s = Math.min(maskCanvas.width, maskCanvas.height);
      if (cfg && cfg.radiusNorm != null) return cfg.radiusNorm * s;
      if (cfg && cfg.radius != null && cfg.natural && cfg.natural.w && cfg.natural.h){
        return (cfg.radius / Math.min(cfg.natural.w, cfg.natural.h)) * s;
      }
      return 24;
    }

    function applyMask(){
      const url = maskCanvas.toDataURL('image/png');
      modLeft.style.webkitMaskImage = `url(${url})`;
      modLeft.style.maskImage = `url(${url})`;
      modLeft.style.webkitMaskSize = '100% 100%';
      modLeft.style.maskSize = '100% 100%';
      modLeft.style.webkitMaskRepeat = 'no-repeat';
      modLeft.style.maskRepeat = 'no-repeat';
      // Ensure no tint: display images as-is
      modLeft.style.filter = 'none'; origLeft.style.filter = 'none'; origRight.style.filter='none';
      modLeft.style.mixBlendMode = 'normal'; origLeft.style.mixBlendMode='normal';
    }

    function clearMask(){
      sizeMaskToDisplay();
      mctx.save();
      mctx.globalCompositeOperation = 'source-over';
      mctx.fillStyle = '#fff';
      mctx.fillRect(0,0,maskCanvas.width,maskCanvas.height);
      mctx.restore();
      applyMask();
    }

    function drawMaskWithHoles(extra){
      clearMask();
      const rect = modLeft.getBoundingClientRect();
      const bw = rect.width, bh = rect.height;
      const R = radiusPx();
      mctx.save();
      mctx.fillStyle = '#000';
      for (const idx of found){
        const p = cfg.points[idx];
        const cx = p.xNorm * bw, cy = p.yNorm * bh;
        mctx.beginPath(); mctx.arc(cx, cy, R, 0, Math.PI*2); mctx.fill();
      }
      if (extra){
        mctx.beginPath(); mctx.arc(extra.x, extra.y, extra.r, 0, Math.PI*2); mctx.fill();
      }
      mctx.restore();
      applyMask();
    }

    function animateReveal(cx, cy, R, done){
      const steps = 12; let i = 0;
      (function step(){
        i++; const r = (i/steps) * R;
        drawMaskWithHoles({x:cx, y:cy, r});
        if (i < steps) requestAnimationFrame(step); else { drawMaskWithHoles(); if (done) done(); }
      })();
    }

    function startTimers(){
      upStart = performance.now();
      if (upTimerId) cancelAnimationFrame(upTimerId);
      const tick = ()=>{
        const ms = performance.now() - upStart;
        const s = Math.floor(ms/1000), m = Math.floor(s/60), r = s%60;
        upTimerEl.textContent = `${String(m).padStart(2,'0')}:${String(r).padStart(2,'0')}`;
        const bms = Math.max(0, BONUS_WINDOW - (performance.now() - bonusStart));
        const b = Math.round((bms/ BONUS_WINDOW) * BONUS_MAX);
        bonusEl.textContent = b;
        bonusFill.style.width = `${(b/BONUS_MAX)*100}%`;
        upTimerId = requestAnimationFrame(tick);
      };
      upTimerId = requestAnimationFrame(tick);
      resetBonus();
    }
    function resetBonus(){ bonusStart = performance.now(); }

    function showGain(val){
      lastGainEl.textContent = (val>0?'+':'') + val;
      lastGainEl.style.display = 'inline-block';
      lastGainEl.style.opacity = '1';
      setTimeout(()=>{ lastGainEl.style.transition='opacity 600ms'; lastGainEl.style.opacity='0'; }, 50);
      setTimeout(()=>{ lastGainEl.style.display='none'; lastGainEl.style.transition=''; }, 700);
    }

    function wrongClick(){ score = Math.max(0, score - 25); scoreEl.textContent = score; flashBorder(leftFrame,'bad'); showGain(-25); }
    function flashBorder(el,kind){ el.style.boxShadow = kind==='bad' ? '0 0 0 3px #ff5c5c88 inset' : '0 0 0 3px #53d76988 inset'; setTimeout(()=> el.style.boxShadow='none', 200); }

    function rect(){ return modLeft.getBoundingClientRect(); }

    function onClickLeft(ev){
      if (!cfg || !imagesReady()) return;
      const r = rect();
      const x = ev.clientX - r.left; const y = ev.clientY - r.top;
      const R = radiusPx();
      // hit test
      let hitIndex = -1;
      cfg.points.forEach((p,idx)=>{
        if (hitIndex!==-1 || found.has(idx)) return;
        const px = p.xNorm * r.width, py = p.yNorm * r.height;
        const dx = x - px, dy = y - py; if (Math.hypot(dx,dy) <= R) hitIndex = idx;
      });
      if (hitIndex === -1){ wrongClick(); return; }
      found.add(hitIndex);
      const p = cfg.points[hitIndex];
      const cx = p.xNorm * r.width, cy = p.yNorm * r.height;
      animateReveal(cx, cy, R, ()=>{
        const currentBonus = Math.max(0, Math.round((BONUS_WINDOW - (performance.now() - bonusStart)) / BONUS_WINDOW * BONUS_MAX));
        const gain = 200 + currentBonus; score += gain; scoreEl.textContent = score; showGain(gain);
        foundEl.textContent = found.size; flashBorder(leftFrame,'good'); resetBonus();
        if (found.size >= (cfg.need || cfg.points.length)) finish();
      });
    }

    function doHint(){
      if (!cfg) return;
      const unresolved = cfg.points.map((p,i)=> i).filter(i=> !found.has(i));
      if (!unresolved.length) return;
      const r = rect();
      const idx = unresolved[Math.floor(Math.random()*unresolved.length)];
      const p = cfg.points[idx];
      const x = p.xNorm*r.width, y = p.yNorm*r.height; const R = radiusPx()*HINT_FACTOR;
      const ring = document.createElement('div'); ring.className='hintPulse';
      ring.style.left = (x - R) + 'px'; ring.style.top = (y - R) + 'px';
      ring.style.width = (R*2)+'px'; ring.style.height = (R*2)+'px';
      leftFrame.appendChild(ring);
      let flashes = 0; const blink = ()=>{ ring.style.transition='opacity 250ms ease'; ring.style.opacity = (ring.style.opacity==='1')?'0':'1'; };
      const interval = setInterval(()=>{ flashes++; blink(); if (flashes>7){ clearInterval(interval); ring.remove(); } }, 200);
    }

    // Loaders
    modFile.onchange = (e)=>{ const f=e.target.files[0]; if(!f) return; const r=new FileReader(); r.onload=()=>{ modImg.src=r.result; modLeft.src=r.result; }; r.readAsDataURL(f); };
    origFile.onchange = (e)=>{ const f=e.target.files[0]; if(!f) return; const r=new FileReader(); r.onload=()=>{ origImg.src=r.result; origLeft.src=r.result; origRight.src=r.result; }; r.readAsDataURL(f); };
    cfgFile.onchange = (e)=>{ const f=e.target.files[0]; if(!f) return; const r=new FileReader(); r.onload=()=>{ try{ cfg=JSON.parse(r.result); resetState(); }catch(err){ alert('Invalid config JSON: '+err.message); } }; r.readAsText(f); };

    function resetState(){
      score = 0; scoreEl.textContent = score; lastGainEl.style.display='none';
      found = new Set(); foundEl.textContent = 0; needEl.textContent = cfg?.need || (cfg?.points? cfg.points.length : 10);
      setAspectToNatural();
      requestAnimationFrame(()=>{ sizeMaskToDisplay(); clearMask(); });
      resetBonus();
    }

    // Start game
    startBtn.onclick = ()=>{
      if (!cfg || !imagesReady()) { alert('Load both images and the config first.'); return; }
      setAspectToNatural();
      document.body.classList.add('playing');
      requestAnimationFrame(()=>{ sizeMaskToDisplay(); clearMask(); startTimers(); });
    };

    // Interactions & resize
    stack.addEventListener('click', onClickLeft);
    hintBtnUnder.onclick = doHint;
    resetBtn.onclick = ()=>{ if(!cfg) return; resetState(); startTimers(); };
    window.addEventListener('resize', ()=>{ if(!cfg) return; sizeMaskToDisplay(); drawMaskWithHoles(); });

    // Finish modal
    function finish(){ cancelAnimationFrame(upTimerId); document.getElementById('sumScore').textContent = score; document.getElementById('sumTime').textContent = upTimerEl.textContent; doneModal.style.display='flex'; }
    closeModal.onclick = ()=> doneModal.style.display='none';
    playAgain.onclick = ()=>{ doneModal.style.display='none'; resetState(); startTimers(); };
  </script>
</body>
</html>
